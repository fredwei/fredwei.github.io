[{"title":"vuejs基础入门","date":"2017-04-26T02:34:00.000Z","path":"2017/04/26/vuejs基础入门/","text":"为什么要学习vuejs？因为这两年vuejs蛮火的，而且易入门，实用。vuejs 是一套构建用户界面的 渐进式框架。vuejs 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。vuejs 现在不支持IE8及以下，以后也不会支持。 一、基本语法1、插值1.1 文本双大括号包裹住变量名1&lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; 1.2 纯HTML使用v-html指令输出html1&lt;div v-html=\"message\"&gt;&lt;/div&gt; 1.3 属性使用v-bind指令绑定dom元素属性1&lt;div v-bind:id=\"message\" v-bind:data-abc=\"message\"&gt;&lt;/div&gt; 1.4 JavaScript 表达式使用双大括号包裹住表达式1234&lt;p&gt;&#123;&#123; number + 1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/p&gt;&lt;p v-bind:id=\"'list-' + id\"&gt;&lt;/p&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。类似于一个function，执行一系列语句后，必须 return 一个结果。 1234&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 不应该在模板表达式中试图访问用户定义的全局变量 2、指令指令（Directives）是带有 v- 前缀的特殊属性 2.1 参数如下：url和doSomething就是传入vue实例的参数，url是一个变量，doSomething是一个方法名12&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;a v-on:click=\"doSomething\"&gt; 2.2 修饰符修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定.prevent修饰符告诉v-on指令对于触发的事件调用event.preventDefault()来阻止默认行为1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; 事件修饰符有：.stop``.prevent``.capture``.self``.once更多修饰符自己查.. 3、过滤器vuejs 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：插值和v-bind表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示 1234&lt;!-- in 插值 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; 123456789101112new Vue(&#123; // ... filters: &#123; // 自定义过滤器 // 过滤器函数总接受表达式的值作为第一个参数 capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) 过滤器可以串联12&lt;!-- 多个过滤器 --&gt;&#123;&#123; message | filterA | filterB &#125;&#125; 过滤器可以接受参数1&#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 字符串&#39;arg1&#39;将传给过滤器作为第二个参数，arg2表达式的值将被求值然后传给过滤器作为第三个参数 4、缩写v-前缀在模板中是作为一个标示 Vue 特殊属性的明显标识，整个应用都使用vuejs的话，那么前缀v-就没有那么重要123456789&lt;!-- v-bind 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- v-bind 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt;&lt;!-- v-on 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- v-on 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 实际是，不用缩写也是挺好的。 二、基本用法在学习之前，先把vuejs下载下来放在本地，直接使用script标签引入即可。 1、声明式渲染1&lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: '#app', data: &#123; message: '你好，程序猿！' &#125;&#125;) 结果输出：你好，程序猿！ 2、绑定 DOM 元素属性123&lt;div id=\"app-2\"&gt; &lt;span v-bind:title=\"message\" v-bind:data-alt=\"message\"&gt;鼠标移动到我上边来&lt;/span&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: '#app-2', data: &#123; message: '什么都没有' &#125;&#125;) 生成HTML：1&lt;div id=\"app-2\"&gt;&lt;span title=\"什么都没有\" data-alt=\"什么都没有\"&gt;鼠标移动到我上边来&lt;/span&gt;&lt;/div&gt; 3、if语句1234&lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;看得见我&lt;/p&gt; &lt;p v-if=\"!seen\"&gt;看不见我&lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;) 在命令行改变app3.seen的值，会看到页面内容的变化 4、for循环1234567&lt;div id=\"app-4\"&gt; &lt;ol&gt; &lt;li v-for=\"item in todos\"&gt; &#123;&#123; item.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: '#app-4', data: &#123; todos: [ &#123; text: '不要学 JavaScript' &#125;, &#123; text: '不要学 Vue' &#125;, &#123; text: '什么都不要学' &#125; ] &#125;&#125;) 生成HTML：12345&lt;ol&gt; &lt;li&gt;不要学 JavaScript&lt;/li&gt; &lt;li&gt;不要学 Vue&lt;/li&gt; &lt;li&gt;什么都不要学&lt;/li&gt;&lt;/ol&gt; 5、v-on监听事件1234&lt;div id=\"app-5\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"toChange\"&gt;点我点我点我&lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: '#app-5', data: &#123; message: '我是一串很长的字符串' &#125;, methods: &#123; toChange: function () &#123; this.message = this.message.split('').reverse().join(''); &#125; &#125;&#125;) 点击按钮，文字会经过toChange方法处理，进行逆序并输出 6、v-model指令在表单输入和应用状态中做双向数据绑定 1234&lt;div id=\"app-6\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=\"message\"&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: '#app-6', data: &#123; message: '写点什么好呢' &#125;&#125;) 改变输入框的值，或者在控制台改变app6.message的值，页面中的文本及输入框的值都会同时改变 三、组件将vuejs应用到开发中，组件是必不可少的部分。 1234567&lt;div id=\"app-7\"&gt; &lt;ol&gt; &lt;todo-item v-for=\"item in list\" v-bind:ccc=\"item\"&gt;&lt;/todo-item&gt; &lt;li v-for=\"item in list\"&gt;2&#123;&#123; item.text &#125;&#125;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 上段代码中，ccc相当于function中接收到的形参，作用于function内部1234567891011121314151617// 定义组件Vue.component('todo-item', &#123; props: ['ccc'], template: '&lt;li&gt;&#123;&#123; ccc.text &#125;&#125;&lt;/li&gt;'&#125;)// vue实例var app7 = new Vue(&#123; el: '#app-7', data: &#123; list: [ &#123; text: '不要学 JavaScript' &#125;, &#123; text: '不要学 Vue' &#125;, &#123; text: '什么都不要学' &#125; ] &#125;&#125;) 以上代码执行后发现，使用组件输出与直接用for循环输出，结果是一致的，但使用组件有更多的可控性 四、总结不需要关注页面dom的操作，只需要管理页面数据即可！","tags":[{"name":"vuejs","slug":"vuejs","permalink":"http://fredwei.com/tags/vuejs/"}]},{"title":"h5唤醒App","date":"2017-04-13T05:37:37.000Z","path":"2017/04/13/h5唤醒App/","text":"首先要声明的一点是，h5页面无法获取app的状态，也就是说，无法判断app是否已下载，app是否已打开。那么基于这个，怎么样实现在h5页面唤醒指定的app呢？请看下回分解~ 一般来讲，app产品都会有一个下载落地页，引导用户前往应用市场下载app应用，安卓的前往安卓市场，ios的跑到appstore。那么先不考虑页面的样式，首先进入到页面，第一步是获取设备信息，也就是浏览器信息。 1、获取设备信息12345678910111213141516171819202122function getPlatform()&#123; var u = navigator.userAgent, app = navigator.appVersion, iosVer = app.match(/OS (\\d+)_(\\d+)_?(\\d+)?/); return &#123; // android终端或者uc浏览器 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, // 是否为iPhone或者QQHD浏览器 iPhone: u.indexOf('iPhone') &gt; -1, // 是否iPad iPad: u.indexOf('iPad') &gt; -1, // ios 版本号 iosVer: iosVer &amp;&amp; parseInt(iosVer[1], 10), // 微信 weChat: u.indexOf('MicroMessenger') &gt; -1, // QQ QQ: u.indexOf('QQ') &gt; -1, // 微博 WeiBo: u.indexOf('weibo') &gt; -1 &#125;;&#125; 2、设置app下载地址安卓应用市场及appstore下载地址各不相同，所以要跟app的童鞋拿到应用下载地址123// 下载链接var _androidUrl = 'http://a.app.qq.com/o/simple.jsp?pkgname=com.ingdan.ingdannews';var _iosUrl = 'https://itunes.apple.com/us/app/in-tou-tiao-zhuan-zhu-zhi/id1197794545?l=zh&amp;ls=1&amp;mt=8'; 3、跳转app下载页面那么页面打开后，就应该判断设备，然后进行页面跳转了1234567891011var _platform = getPlatform();var _downloadUrl = _androidUrl;if(_platform.android)&#123; // 安卓&#125;else&#123; // ios _downloadUrl = _iosUrl;&#125;window.location.href = _downloadUrl; 是不是很完美了，当然不是，app还没打开呢，而且在各个不同环境有不同限制，例如在微信或微博中打开，是不允许直接跳转到appstore，那怎么解决？12345678if(_platform.android)&#123; // 安卓&#125;else&#123; // ios if(_platform.weChat || _platform.WeiBo)&#123; alert('请再浏览器中打开本页面~速去'); &#125;&#125; 看起来十分完美，然而还是没有，app也还没打开呢 4、打开APP如何打开app呢，这里需要注意的一点事，打开app必须要开发的童靴提供一个自定义协议，例如： 1var _appUrl = 'INNewsApp://'; 其中INNewsApp://是app开发自行决定的协议，当然最好后边能跟上app相对应的域名，如：INNewsApp://m.ingdan.com如果需要打开app后跳转到指定页面，那么就应该在链接中加入参数，如：INNewsApp://m.ingdan.com?id=9527 打来app地址有了，接下来如何处理？我们这里使用iframe来打开，避免了一旦url有误，或者手机上没有安装app导致报错。 1234567// 在iframe 中打开APPvar ifr = document.createElement('iframe');ifr.style.display = 'none';ifr.src = _appUrl;document.body.appendChild(ifr); 到了这时，在测试ios的时候发现一个问题，ios9以上，不支持iframe打开app于是乎1234567// 判断ios版本，ios9以上直接打开if(_platform.iosVer &gt;= 9)&#123; window.location.href = _appUrl;&#125;else&#123; // 在iframe 中打开APP // ...&#125; 如果手机上安装有app，这是h5就可以唤醒app，app就启动了。 5、一些兼容处理产品这时希望，那么如果手机上没有安装app，怎跳转到app下载页面，怎么办？先把产品打一顿再说 1234567setTimeout(function() &#123; // 2秒之后，移除iframe document.body.removeChild(ifr); // 跳转到app下载地址 window.location.href = _downloadUrl;&#125;, 2000); 这样似乎已经完美了，然后还没有。一般情况下，浏览器处于非激活状态、使用alert弹出信息或者系统信息提示，页面是会中断js运行的然后在QQ安卓版的内置浏览器上，并没有，更为让人开心的是，如果你的app是跳转到应用宝上，应用宝会自动判断你是否一下子该app，并且还很友好的帮你打开这个时候你就会发现，在QQ内置浏览器打开下载引导页面，app打开了，正看得高兴，过了2秒，app又打开一次… 于是乎1234// 非QQ内置浏览器if(!_platform.QQ)&#123; window.location.href = _downloadUrl;&#125; 那在QQ安卓版的内置浏览器上，如果有app，则自动打开，如果没有，怎么引导用户下载？页面上那么大一颗下载按钮，自己点吧。","tags":[]},{"title":"web workers","date":"2017-04-12T11:26:19.000Z","path":"2017/04/12/workers/","text":"javascript执行时，只有一条线程，也就是从上至下的去执行。如果某些脚本比较复杂、耗时，那么将会阻塞javascript继续执行，甚至导致浏览器失去响应。那么要实现javascript的多线程，可以使用定时器来实现。除了定时器，如今还可以使用woker来实现多线程处理。未完待续…","tags":[{"name":"html5","slug":"html5","permalink":"http://fredwei.com/tags/html5/"},{"name":"workers","slug":"workers","permalink":"http://fredwei.com/tags/workers/"},{"name":"web api","slug":"web-api","permalink":"http://fredwei.com/tags/web-api/"}]},{"title":"使用webpack构建时给window绑定事件的坑","date":"2017-03-28T07:45:25.000Z","path":"2017/03/28/使用webpack构建时给window绑定事件的坑/","text":"使用webpack进行构建，给window绑定了onload的事件，结果竟然死活不触发！各种排除后发现问题所在… 业务js文件index.js 12345678var $ = require('jquery');$(function()&#123; // 在这里绑定，无效 $(window).on('load', function()&#123; console.log('页面加载完成了~'); &#125;);&#125;) 打开页面，然后控制台并没有打印出“页面加载完成了~” 难道是使用jquery进行绑定的原因导致事件绑定无效？于是改了代码： 12345678var $ = require('jquery');$(function()&#123; // 在这里绑定，还是无效 window.onload = function()&#123; console.log('页面加载完成了~'); &#125;;&#125;) 控制台依然没有打印出预期的结果，苦思良久，改成 123456789101112131415var $ = require('jquery');// 在这里绑定，有效$(window).on('load', function()&#123; console.log('页面加载完成了~ 1');&#125;);// 在这里绑定，也有效window.onload = function()&#123; console.log('页面加载完成了~ 2');&#125;;$(function()&#123; &#125;) 那看来是’$(function(){})’这一段代码的问题了，这段代码并不难理解，当页面的dom结构加载完毕则执行，刚入门是使用’script’标签引入jquery，并没有这样的问题出现。 那么现在看来是使用webpack进行构建的并发症了，至于原因，并没有深究的意愿。 现在页面的js基本都是放在页面底部，程序执行到这里，其实意味着dom结构以及渲染完毕了，个人觉得在js中写’$(function(){})’是没有必要了的","tags":[{"name":"webpack","slug":"webpack","permalink":"http://fredwei.com/tags/webpack/"},{"name":"jquery","slug":"jquery","permalink":"http://fredwei.com/tags/jquery/"}]},{"title":"使用hexo遇到的一个坑","date":"2017-03-23T03:46:16.000Z","path":"2017/03/23/使用hexo遇到的一个坑/","text":"hexo中首页列表的摘要（excerpt）弄不出来，一直显示全文 修改了N多配置都不生效，官方文档中也没有说明，唯有各种搜索答案，终于找到了！ 原来只需要在文中加入&lt;!-- more --&gt;就可以了，这实在是个大坑！ 12345这就是一个简介&lt;!-- more --&gt; 这里更多的内容 原答案链接","tags":[{"name":"hexo","slug":"hexo","permalink":"http://fredwei.com/tags/hexo/"}]},{"title":"Express路由","date":"2017-03-22T08:11:33.000Z","path":"2017/03/22/express路由/","text":"一、简介 1、Express 是一个基于 Node.js 平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 2、丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。 （ Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架） 3、Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。 &nbsp; 二、express环境搭建1、安装nodejs和npm，建议安装淘宝提供的国内镜像cnpm，这样安装比较快 1$ npm install –g cnpm 2、新建一个目录，在目录下执行 1$ cnpm install express --save 3、express环境已经搭建好了 &nbsp; 三、基本路由1、简单版，除了get请求，还有post、put、delete 123456789101112131415161718192021222324252627282930313233343536373839404142var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World! &lt;a href=\"/news\"&gt;to news&lt;/a&gt;');&#125;);app.get('/news', function (req, res) &#123; res.send('this is news. &lt;a href=\"/\"&gt;back&lt;/a&gt;');&#125;).post('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a post request!', data: req.query &#125;);&#125;).put('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a put request!', data: req.query &#125;);&#125;).delete('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a delete request!', data: req.query &#125;);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 2、字符匹配模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var express = require('express');var app = express();// 路径var _routeStr = ['start'];var _routeList = ['&lt;ol&gt;'];_routeList.push('&lt;li&gt;ab?cd（匹配 acd 和 abcd）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab+cd（匹配 abcd、abbcd、abbbcd等）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab*cd（匹配 abcd、abxcd、abRABDOMcd、ab123cd等）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab(cd)?e（匹配 /abe 和 /abcde）&lt;/li&gt;');_routeList.push('&lt;/ol&gt;');app.all('*', function (req, res, next) &#123; console.log('Accessing：' + new Date()); _routeStr = ['start']; next();&#125;);// 匹配 acd 和 abcdapp.get('/ab?cd', function(req, res, next) &#123; // res.send('ab?cd'); _routeStr.push('ab?cd'); next();&#125;);// 匹配 abcd、abbcd、abbbcd等app.get('/ab+cd', function(req, res, next) &#123; // res.send('ab+cd'); _routeStr.push('ab+cd'); next();&#125;);// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等app.get('/ab*cd', function(req, res, next) &#123; // res.send('ab*cd'); _routeStr.push('ab*cd'); next();&#125;);// 匹配 /abe 和 /abcdeapp.get('/ab(cd)?e', function(req, res, next) &#123; // res.send('ab(cd)?e'); _routeStr.push('ab(cd)?e'); next();&#125;);app.get('*', function(req, res) &#123; _routeStr.push('end'); var _html = '&lt;p&gt;' + _routeStr.join(' ====&gt; ') + '&lt;/p&gt;'; res.send(_routeList.join('') + _html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 3、正则匹配模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var express = require('express');var app = express();// 路径var _routeStr = ['start'];var _routeList = ['&lt;ol&gt;'];_routeList.push('&lt;li&gt;/a/（匹配任何路径中含有 a 的路径');_routeList.push('&lt;li&gt;/.*fly$/（匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等）&lt;/li&gt;');_routeList.push('&lt;/ol&gt;');app.all('*', function (req, res, next) &#123; console.log('Accessing：' + new Date()); _routeStr = ['start']; next();&#125;);// 匹配任何路径中含有 a 的路径：app.get(/a/, function(req, res, next) &#123; _routeStr.push('/a/'); next();&#125;);// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等app.get(/.*fly$/, function(req, res, next) &#123; _routeStr.push('/.*fly$/'); next();&#125;);app.get('*', function(req, res) &#123; _routeStr.push('end'); var _html = '&lt;p&gt;' + _routeStr.join(' ====&gt; ') + '&lt;/p&gt;'; res.send(_routeList.join('') + _html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 3、执行多个回调 1234567891011121314151617181920212223242526272829303132333435363738var express = require('express');var app = express();// 多个回调函数，需指定执行nextapp.get('/b', function (req, res, next) &#123; console.log('this is function b one'); next();&#125;, function (req, res) &#123; console.log('this is function b two'); res.send('Hello from B!');&#125;);// 多个回调传入，需指定执行next，最后必须有sendvar cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;var cb2 = function (req, res) &#123; res.send('Hello from C!');&#125;app.get('/c', [cb0, cb1, cb2]);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); &nbsp; 四、中间件router1、通过require导入各种路由配置文件 12345678910111213141516171819202122var express = require('express');var app = express();var _router1 = require('./router/r1.js');var _router2 = require('./router/r2.js');var _router3 = require('./router/r3.js');var _router4 = require('./router/r4.js');app.use('/', _router1);app.use('/r2', _router2);app.use('/r3', _router3);app.use('/r4', _router4);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 2、简单版 1234567891011121314151617181920var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 定义网站主页的路由router.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// 定义 about 页面的路由router.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 3、通过路由中间件控制 1234567891011121314151617181920212223242526272829303132333435363738var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息router.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 一个中间件栈，处理指向 /user/:id 的 GET 请求router.get('/user/:id', function (req, res, next) &#123; console.log(req.params, req.params.id == 0); // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0)&#123; res.send('ID：' + req.params.id); &#125; // 负责将控制权交给栈中下一个中间件 else&#123; next(); &#125;&#125;, function (req, res, next) &#123; // 渲染常规页面 res.send('next function ID：' + req.params.id); // 填到下一个路由 // next();&#125;);module.exports = router; 使用router.param 123456789101112131415161718192021222324252627282930var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);var _pid;router.get('/blog/:pid', function (req, res, next) &#123; console.log('get function');&#125;);router.param('pid', function (req, res, next, pid)&#123; console.log('param function'); // console.log(req.query); setTimeout(function()&#123; _pid = pid; res.send('my pid is：' + pid + '&amp;&amp;' + req.query.id); &#125;, 1000); next();&#125;);module.exports = router; 多个参数的情况下 12345678910111213141516171819202122232425262728293031323334353637var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 无效，可能是版本问题// router.param(['id', 'page'], function (req, res, next, value) &#123;// console.log('CALLED ONLY ONCE with', value);// next();// &#125;)router.param('nid', function (req, res, next, value) &#123; console.log('nid：', value); next();&#125;);router.param('page', function (req, res, next, value) &#123; console.log('page：', value); next();&#125;);router.get('/news/:nid/:page', function (req, res, next) &#123; console.log('although this matches'); next();&#125;);router.get('/news/:nid/:page', function (req, res) &#123; console.log('and this matches too'); res.send('ok');&#125;);module.exports = router; &nbsp; 五、静态资源目录也算是属于路由中的一部分，负责静态资源的路径设置 1234567891011121314151617181920212223242526var express = require('express');var app = express();app.use(express.static(__dirname + '/images'));app.use('/pic', express.static(__dirname + '/images'));app.use('/img', express.static(__dirname + '/images'));app.get('/img', function (req, res) &#123; var _html = ''; _html += '&lt;p&gt;/icon.png&lt;/p&gt;&lt;img src=\"/icon.png\" /&gt;'; _html += '&lt;p&gt;/pic/icon.png&lt;/p&gt;&lt;img src=\"/pic/icon.png\" /&gt;'; _html += '&lt;p&gt;/img/icon.png&lt;/p&gt;&lt;img src=\"/img/icon.png\" /&gt;'; res.send(_html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); &nbsp; 六、实例源码github express_demo","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://fredwei.com/tags/nodejs/"},{"name":"express","slug":"express","permalink":"http://fredwei.com/tags/express/"},{"name":"router","slug":"router","permalink":"http://fredwei.com/tags/router/"}]}]