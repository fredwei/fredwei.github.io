[{"title":"使用 vue-element-admin 开发一个后台管理——发布上线","date":"2018-03-15T02:41:41.000Z","path":"2018/03/15/使用-vue-element-admin-开发一个后台管理——发布上线/","text":"本地开发完成，接着就需要上传到外网环境，让测试的童鞋来做测试了。 发布上线发布上线之前，首先是要打包构建，生成最终代码。然后在打包构建之前，还需要对配置文件进行修改。 打包构建需要修改的配置文件主要在\\config\\目录中，dev.env.js、sit.env.js和prop.env.js分别对应开发、测试、生产环境，文件的配置项基本一致，如下： 12345module.exports = &#123; NODE_ENV: '\"production\"', ENV_CONFIG: '\"sit\"', BASE_API: '\"https://api-sit\"'&#125; 这里都是全局变量，可以在开发过程中直接引用，如在\\src\\utils\\request.js请求封装的文件中： 12345// create an axios instanceconst service = axios.create(&#123; baseURL: process.env.BASE_API, // api的base_url timeout: 5000 // request timeout&#125;) 通过process.env.BASE_API直接调用\\config\\中配置文件里的BASE_API。 如果需要修改构建打包输出的配置，可以打开\\config\\index.js文件，找到build配置项： 12345678910111213141516171819module.exports = &#123; dev: &#123; ... &#125;, build: &#123; // 资源构建打包输出的入口文件 index: path.resolve(__dirname, '../dist/index.php'), // 资源构建打包输出的本地路径 assetsRoot: path.resolve(__dirname, '../dist'), // 这是将静态资源打包到指定的文件夹下 assetsSubDirectory: 'static', // 这是静态资源的路径 assetsPublicPath: './', ... &#125;&#125; 主要是修改assetsSubDirectory和assetsPublicPath选项，如果你的资源服务器和web服务器不在同一台机器，那么正好修改这里，例如： 12345678910111213141516171819module.exports = &#123; dev: &#123; ... &#125;, build: &#123; // 资源构建打包输出的入口文件 index: path.resolve(__dirname, '../dist/index.php'), // 资源构建打包输出的本地路径 assetsRoot: path.resolve(__dirname, '../dist'), // 这是将静态资源打包到指定的文件夹下 assetsSubDirectory: 'static', // 这是静态资源的路径 assetsPublicPath: '//static.demo.com/', ... &#125;&#125; 配置文件修改完毕之后，在命令行输入： 1npm run build:sit 以上构建命令是打包到测试环境，等待命令窗口显示打包构建完成，在\\dist\\index.php文件中会发现，所有静态资源的链接都是//static.demo.com/static/开头。 假如web服务器是php环境，地址是http://www.demo.com/，那么把\\dist\\index.php这个入口文件上传到web服务器的根目录；再把\\dist\\static\\整个目录上传到http://static.demo.com/的根目录。 完成以上操作，就可以通过地址http://www.demo.com/访问到你发布完成的网站了。 补充：除了修改\\config\\目录中的配置，还可以按需修改\\build\\目录中的配置，webpack.dev.conf.js和webpack.prop.conf.js，其中测试和生产环境共用webpack.prop.conf.js的配置。 结语教程中还有许多不足之处，有一些地方没有讲述清楚，有任何问题或者建议，欢迎联系我进行友好的沟通交流~ 系列文章 使用-vue-element-admin-开发一个后台管理——初始化 使用-vue-element-admin-开发一个后台管理——接口约定 使用-vue-element-admin-开发一个后台管理——mock数据 使用-vue-element-admin-开发一个后台管理——国际化 使用-vue-element-admin-开发一个后台管理——登录 使用-vue-element-admin-开发一个后台管理——首页 使用-vue-element-admin-开发一个后台管理——新建栏目 使用-vue-element-admin-开发一个后台管理——接口联调 使用-vue-element-admin-开发一个后台管理——发布上线 相关文档 vue mockjs element-ui vue-element-admin vue-el-admin-tpl","tags":[{"name":"vue","slug":"vue","permalink":"http://fredwei.com/tags/vue/"},{"name":"admin","slug":"admin","permalink":"http://fredwei.com/tags/admin/"},{"name":"element","slug":"element","permalink":"http://fredwei.com/tags/element/"}]},{"title":"使用 vue-element-admin 开发一个后台管理——接口联调","date":"2018-03-15T02:41:02.000Z","path":"2018/03/15/使用-vue-element-admin-开发一个后台管理——接口联调/","text":"在本地开发环境也是可以与后台服务器接口进行调试的，需要解决的问题就是跨域问题。如果是线上的跨越问题，解决办法有很多，常用的有CORS，全称为 Cross Origin Resource Sharing（跨域资源共享），这种方案工作量基本都在后端那里，在此不多介绍。 接口联调在联调之前，首选需要去掉mock数据，否则mock会一直拦截请求接口。去掉mock很简单，直接注释\\src\\main.js中的引用即可： 1// import './mock' 接着还需要修改一下开发环境的配置，在本项目中，打开\\config\\index.js文件，修改dev的proxyTable配置，如下： 123456789101112module.exports = &#123; dev: &#123; // Paths assetsSubDirectory: 'static', assetsPublicPath: '/', // dev开发模式跨域处理 proxyTable: &#123; '/api': 'http://test.api.com' &#125;, ... &#125;&#125; 这样子就可以完成简单的跨域处理，例如请求到/api/users现在会被代理到请求http://test.api.com/api/users。但是在浏览器开发工具的network中并不会体现出来，可以通过查看返回值或者在浏览器直接访问接口地址如http://localhost:9527/api/users，检查代理是否设置正确。 修改完毕之后，需要关闭本地服务，然后再启动，否则配置文件不能生效。（ctrl+c无法关掉本地服务的，直接在进程里边关掉） 全部调整完毕，就可以跟和后端愉快的调试了，本地测试通过，那么接下来就应该上传到服务器，在外网环境测试了。 系列文章 使用-vue-element-admin-开发一个后台管理——初始化 使用-vue-element-admin-开发一个后台管理——接口约定 使用-vue-element-admin-开发一个后台管理——mock数据 使用-vue-element-admin-开发一个后台管理——国际化 使用-vue-element-admin-开发一个后台管理——登录 使用-vue-element-admin-开发一个后台管理——首页 使用-vue-element-admin-开发一个后台管理——新建栏目 使用-vue-element-admin-开发一个后台管理——接口联调 使用-vue-element-admin-开发一个后台管理——发布上线 相关文档 vue mockjs element-ui vue-element-admin vue-el-admin-tpl","tags":[{"name":"vue","slug":"vue","permalink":"http://fredwei.com/tags/vue/"},{"name":"admin","slug":"admin","permalink":"http://fredwei.com/tags/admin/"},{"name":"element","slug":"element","permalink":"http://fredwei.com/tags/element/"}]},{"title":"使用 vue-element-admin 开发一个后台管理——新建栏目","date":"2018-03-15T02:40:00.000Z","path":"2018/03/15/使用-vue-element-admin-开发一个后台管理——新建栏目/","text":"vue-el-admin-tpl中默认一个栏目中有三个页面，分别是列表、新增、编辑，其中新增跟编辑使用同一个模版。如有其他页面，可以自行添加。 新建栏目以下是从无到有创建一个栏目的过程 新建页面文件(1) 在\\src\\views\\目录下新建一个product目录，并新建文件index.vue、add.vue、edit.vue三个页面(2) 在\\src\\router\\index.js文件中加上product栏目列表页的路由信息，如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647export const asyncRouterMap = [ // 产品 &#123; path: '/product', component: Layout, redirect: '/product/index', meta: &#123; title: 'product', icon: 'component' &#125;, children: [&#123; // 首页 path: 'index', component: _import('product/index'), name: 'product', hidden: true, meta: &#123; title: 'product', icon: 'component' &#125; &#125;, &#123; // 新增 path: 'add', component: _import('product/add'), name: 'productAdd', hidden: true, meta: &#123; title: 'productAdd', icon: 'form', roles: ['admin', 'editor'] &#125; &#125;, &#123; // 编辑 path: 'edit/:id', component: _import('product/edit'), name: 'productEdit', hidden: true, meta: &#123; title: 'productEdit', icon: 'form', roles: ['admin'] &#125; &#125;] &#125;, // 404页面拦截 &#123; path: '*', redirect: '/404', hidden: true &#125;] 因为后台的页面（除了登录）都使用同一个页面框架，封装在\\src\\views\\layout\\Layout.vue，所以栏目路由的component设置为Layout，并且重定向到/product/index。不想在左侧菜单显示列表、新增跟编辑才到，所以hidden设置为true，左侧菜单这块有做过特别的处理 路由写好之后，要记得在语言包中写上对应的文字，打开\\src\\lang\\zh.js和\\src\\lang\\en.js，根据在路由表中设置的title值，一一对应在语言包文件中的route对象中加对应字段的文字，如下： 1234567891011121314151617181920212223// zh.jsexport default &#123; route: &#123; home: '首页', news: '新闻', product: '产品', productAdd: '添加产品', productEdit: '编辑产品', ... &#125;&#125;// en.jsexport default &#123; route: &#123; home: 'Home', news: 'News', product: 'Product', productAdd: 'Product Add', productEdit: 'Product Edit', ... &#125;&#125; 以上处理好了之后，就可以通过/product/index、/product/add和/product/edit/xxx访问对应的页面了 列表页列表页主要包含三块区域：列表操作区、列表展示区、列表页码区，页面结构如下： 1234567891011121314151617181920&lt;!-- \\src\\views\\product\\index.vue --&gt;&lt;template&gt; &lt;div class=\"app-container calendar-list-container\"&gt; &lt;!-- 头部操作区 --&gt; &lt;div class=\"filter-container\"&gt; ... &lt;/div&gt; &lt;!-- 表格 --&gt; &lt;el-table&gt; ... &lt;/el-table&gt; &lt;!-- 页码 --&gt; &lt;div class=\"pagination-container\"&gt; ... &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 具体的内容不详细列举，可以参考源码，页面中的ui组件都可以在element-ui和vue-element-admin中找到。 页面操作及数据处理部分如下：1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt;// 数据接口import &#123; fetchList, fetchPv, updateArticle &#125; from '@/api/article'// 按钮动画特效 - 水波纹指令import waves from '@/directive/waves'// 工具接口import &#123; parseTime &#125; from '@/utils'export default &#123; name: 'product', directives: &#123; waves &#125;, data() &#123; return &#123; // 表格的key，改变后表格会重新渲染 tableKey: 0, // 列表数据集 list: null, ... &#125; &#125;, filters: &#123; // 一些过滤器方法 ... &#125;, created() &#123; this.getList() &#125;, methods: &#123; // 获取列表数据 getList() &#123; ... &#125; ... &#125;&#125;&lt;/script&gt; 页面中使用到的数据接口，可以参考mock数据的处理来完成。 新增及编辑页新增及编辑页面使用同样的页面模板，所以需要封装起来，在\\src\\views\\product\\目录下新建一个components组件目录，新建ArticleDetail.vue作为共同模板 新增及编辑页面结构如下： 123456789101112131415161718192021222324252627&lt;!-- \\src\\views\\product\\add.vue --&gt;&lt;template&gt; &lt;article-detail :is-edit='false'&gt;&lt;/article-detail&gt;&lt;/template&gt;&lt;script&gt;import ArticleDetail from './components/ArticleDetail'export default &#123; name: 'productAdd', components: &#123; ArticleDetail &#125;&#125;&lt;/script&gt;&lt;!-- \\src\\views\\product\\edit.vue --&gt;&lt;template&gt; &lt;article-detail :is-edit='true' :detailId=\"this.$route.params.id\"&gt;&lt;/article-detail&gt;&lt;/template&gt;&lt;script&gt;import ArticleDetail from './components/ArticleDetail'export default &#123; name: 'productEdit', components: &#123; ArticleDetail &#125;&#125;&lt;/script&gt; 在调用ArticleDetail组件的时候传入两个值，一个是is-edit，一个是detailId，新增页detailId为空。 在ArticleDetail组件中判断is-edit是否为true并且detailId的值不会空时，会根据detailId的值获取详细信息，在表单中显示。 表单校验表单校验是每个表单都需要处理的部分，element-ui对这一块做了集成处理，使用方式如下： (1) 先定义校验规则123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051export default &#123; name: 'productDetail', components: &#123; ... &#125;, props: &#123; ... &#125;, data() &#123; // 字段校验 - 必填 const validateRequire = (rule, value, callback) =&gt; &#123; if (!value.length) &#123; callback(new Error(rule.field + '为必填项')) &#125; else &#123; callback() &#125; &#125; // 字段校验 - URL const validateSourceUri = (rule, value, callback) =&gt; &#123; if (value) &#123; if (validateURL(value)) &#123; callback() &#125; else &#123; callback(new Error(rule.field + '链接填写不正确')) &#125; &#125; else &#123; callback(new Error(rule.field + '为必填项')) &#125; &#125; return &#123; ... // 校验规则 - 注意：被校验的字段必须加上prop属性 rules: &#123; image_uri: [&#123; validator: validateRequire &#125;], pic_uri: [&#123; validator: validateRequire &#125;], title: [ &#123; validator: validateRequire, trigger: 'blur' &#125;, &#123; min: 2, max: 100, message: '长度在 2 到 100 个字符', trigger: 'blur' &#125; ], content_short: [ &#123; validator: validateRequire &#125;, &#123; min: 5, max: 200, message: '长度在 5 到 100 个字符', trigger: 'blur' &#125; ], content: [&#123; validator: validateRequire &#125;], source_uri: [&#123; validator: validateSourceUri, trigger: 'blur' &#125;] &#125; ... &#125; &#125;, ...&#125; 校验规则rules在data中去设定，有默认约定的校验格式（element-ui 表单校验），也可以自定义函数来进行处理，如上所示。 (2) 应用表单校验 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div class=\"createPost-container\"&gt; &lt;el-form class=\"form-container\" :model=\"postForm\" :rules=\"rules\" ref=\"postForm\" label-width=\"65px\"&gt; &lt;el-form-item style=\"margin-bottom: 40px;\" label=\"标题:\" prop=\"title\"&gt; &lt;el-input placeholder=\"请输入标题，不超过100个字符\" v-model=\"postForm.title\"&gt; &lt;/el-input&gt; &lt;span v-show=\"postForm.title.length&gt;=26\" class='title-prompt'&gt;标题长度超过26个字符时提示&lt;/span&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// ... 省略各种引用export default &#123; name: 'productDetail', components: &#123; ... &#125;, props: &#123; ... &#125;, data() &#123; ... &#125; &#125;, methods: &#123; // 提交数据-发布上线 submitForm() &#123; console.log(this.postForm) // 表单校验 this.$refs.postForm.validate(valid =&gt; &#123; if (valid) &#123; console.log('表单校验通过!') &#125; else &#123; console.log('表单校验不通过!') return false &#125; &#125;) &#125;, ... &#125;, ...&#125;&lt;script&gt; 注意：在el-form组件中，设定校验规则:rules=&quot;rules&quot;在el-form-item组件中，设定校验规则prop=&quot;title&quot;，否则在执行表单校验时，不会对该字段进行校验 表单常见字段表单中经常出现的几种字段类型： (1) 文本输入框1234567&lt;template&gt; &lt;el-form-item style=\"margin-bottom: 40px;\" label=\"标题:\" prop=\"title\"&gt; &lt;el-input placeholder=\"请输入标题，不超过100个字符\" v-model=\"postForm.title\"&gt;&lt;/el-input&gt; &lt;span v-show=\"postForm.title.length&gt;=26\" class='title-prompt'&gt;标题长度超过26个字符时提示&lt;/span&gt; &lt;/el-form-item&gt;&lt;/template&gt; (2) 单选多选1234567891011&lt;template&gt;&lt;el-radio-group style=\"padding: 10px;\" v-model=\"postForm.comment_disabled\"&gt; &lt;el-radio :label=\"true\"&gt;关闭评论&lt;/el-radio&gt; &lt;el-radio :label=\"false\"&gt;打开评论&lt;/el-radio&gt;&lt;/el-radio-group&gt;&lt;el-checkbox-group v-model=\"postForm.platforms\" style=\"padding: 5px 15px;\"&gt; &lt;el-checkbox label=\"多选1\"&gt;多选1&lt;/el-checkbox&gt; &lt;el-checkbox label=\"多选2\"&gt;多选2&lt;/el-checkbox&gt;&lt;/el-checkbox-group&gt;&lt;/template&gt; (3) 时间选择123&lt;template&gt; &lt;el-date-picker v-model=\"postForm.display_time\" type=\"datetime\" format=\"yyyy-MM-dd HH:mm:ss\" placeholder=\"选择日期时间\"&gt;&lt;/el-date-picker&gt;&lt;/template&gt; 注意：设置时间选择器默认值时，默认值必须转成Date类型，否则时间选择器会报错，导致无法正常使用！ (4) 搜索选择12345678&lt;template&gt; &lt;el-form-item label=\"作者:\" class=\"postInfo-container-item\" prop=\"author\"&gt; &lt;multiselect v-model=\"postForm.author\" :options=\"userLIstOptions\" @search-change=\"getRemoteUserList\" placeholder=\"搜索用户\" selectLabel=\"选择\" deselectLabel=\"删除\" track-by=\"key\" :internalSearch=\"false\" label=\"key\"&gt; &lt;span slot='noResult'&gt;无结果&lt;/span&gt; &lt;/multiselect&gt; &lt;/el-form-item&gt;&lt;/template&gt; 注意：vue-element-admin在这里使用的是vue-multiselect一个外部的多选组件，可以参考文档vue-multiselect搜索选择功能需要定义一个方法，用来处理输入框改变时发起请求，实时获取根据关键词检索出来的结果。 1234567891011121314151617181920&lt;template&gt; &lt;el-form-item label=\"作者:\" class=\"postInfo-container-item\" prop=\"author\"&gt; &lt;el-select v-model=\"postForm.author\" multiple filterable remote reserve-keyword placeholder=\"请输入关键词\" :remote-method=\"getRemoteUserList\" :loading=\"loading\"&gt; &lt;el-option v-for=\"item in userLIstOptions\" :key=\"item.value\" :label=\"item.label\" :value=\"item.value\"&gt; &lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt;&lt;/template&gt; 注意：这里使用的是element-ui提供的集成方案，可以参考文档element-ui 选择组件 (5) 图片上传123456789&lt;template&gt; &lt;el-form-item style=\"margin-bottom: 40px;\" label=\"封面图:\" prop=\"image_uri\"&gt; &lt;Upload :fileList=\"postForm.image_uri\"&gt;&lt;/Upload&gt; &lt;/el-form-item&gt; &lt;el-form-item style=\"margin-bottom: 40px;\" label=\"产品图:\" prop=\"pic_uri\"&gt; &lt;Upload :fileList=\"postForm.pic_uri\"&gt;&lt;/Upload&gt; &lt;/el-form-item&gt;&lt;/template&gt; 注意：这是我基于element-ui的文件上传再次封装的，只需传入一个图片数组即可，默认为空数组，数组格式如下：1234567891011121314151617&#123; ... // 文章封面图 image_uri: [&#123; name: 'food.jpeg', url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100' &#125;], // 文章图片 pic_uri: [&#123; name: 'food.jpeg', url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100' &#125;, &#123; name: 'food2.jpeg', url: 'https://fuss10.elemecdn.com/3/63/4e7f3a15429bfda99bce42a18cdd1jpeg.jpeg?imageMogr2/thumbnail/360x360/format/webp/quality/100' &#125;], ...&#125; 其余的默认值可以查看\\src\\components\\Upload\\singleImage4.vue，选择性的传入 (6) 多行文本1234567891011&lt;template&gt;&lt;el-form-item style=\"margin-bottom: 40px;\" label=\"摘要:\" prop=\"content_short\"&gt; &lt;el-input type=\"textarea\" :autosize=\"&#123; minRows: 2, maxRows: 4&#125;\" placeholder=\"请输入摘要，不超过200字\" v-model=\"postForm.content_short\"&gt; &lt;/el-input&gt; &lt;span class=\"word-counter\" v-show=\"contentShortLength\"&gt;&#123;&#123;contentShortLength&#125;&#125;字&lt;/span&gt;&lt;/el-form-item&gt;&lt;/template&gt; (7) 富文本编辑器1234567&lt;template&gt;&lt;el-form-item style=\"margin-bottom: 40px;\" label=\"内容:\" prop=\"content\"&gt; &lt;div class=\"editor-container\"&gt; &lt;tinymce :height=500 ref=\"editor\" v-model=\"postForm.content\"&gt;&lt;/tinymce&gt; &lt;/div&gt;&lt;/el-form-item&gt;&lt;/template&gt; 表单中其余用到的字段类型，可以参考文档element-ui 把提交的接口写好，那么这个栏目就算是开发完成了，在本地调试没问题后，就可以与后端的接口进行一下联调了。 系列文章 使用-vue-element-admin-开发一个后台管理——初始化 使用-vue-element-admin-开发一个后台管理——接口约定 使用-vue-element-admin-开发一个后台管理——mock数据 使用-vue-element-admin-开发一个后台管理——国际化 使用-vue-element-admin-开发一个后台管理——登录 使用-vue-element-admin-开发一个后台管理——首页 使用-vue-element-admin-开发一个后台管理——新建栏目 使用-vue-element-admin-开发一个后台管理——接口联调 使用-vue-element-admin-开发一个后台管理——发布上线 相关文档 vue mockjs element-ui vue-element-admin vue-el-admin-tpl","tags":[{"name":"vue","slug":"vue","permalink":"http://fredwei.com/tags/vue/"},{"name":"admin","slug":"admin","permalink":"http://fredwei.com/tags/admin/"},{"name":"element","slug":"element","permalink":"http://fredwei.com/tags/element/"}]},{"title":"使用 vue-element-admin 开发一个后台管理——首页","date":"2018-03-15T02:39:03.000Z","path":"2018/03/15/使用-vue-element-admin-开发一个后台管理——首页/","text":"首页只保留了几个统计数据跟一个线形图表，这一块可以参考vue-element-admin，根据业务需要自行定义页面元素。 首页首页的视图目录有一个components目录，凭着就近原则，每个栏目独立的组件都应该放到当前栏目下，以便进行管理。对组件的应用如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div class=\"dashboard-editor-container\"&gt; &lt;!-- 调用PanelGroup组件 --&gt; &lt;panel-group :totalData=\"totalData\" :activeType=\"activeType\" @handleSetLineChartData=\"handleSetLineChartData\"&gt;&lt;/panel-group&gt; &lt;el-row style=\"background:#fff;padding:16px 16px 0;margin-bottom:32px;\"&gt; &lt;!-- 调用LineChart组件 --&gt; &lt;line-chart :chart-data=\"lineChartData\"&gt;&lt;/line-chart&gt; &lt;/el-row&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 引用PanelGroup组件import PanelGroup from './components/PanelGroup'// 引用LineChart组件import LineChart from './components/LineChart'export default &#123; name: 'home', // 将引入的组件进行注册，才可以在template中应用 components: &#123; PanelGroup, LineChart &#125;, data() &#123; return &#123; activeType: '', totalData: [], lineChartData: &#123; expectedData: [], actualData: [] &#125; &#125; &#125; ...&#125; 对组件的应用时，建议将子组件需要操作的数据及对该数据处理放在父组件来进行。 首页的相关文件目录如下：视图 \\src\\views\\home\\接口 \\src\\api\\home.js模拟数据 \\src\\mock\\statistics.js 系列文章 使用-vue-element-admin-开发一个后台管理——初始化 使用-vue-element-admin-开发一个后台管理——接口约定 使用-vue-element-admin-开发一个后台管理——mock数据 使用-vue-element-admin-开发一个后台管理——国际化 使用-vue-element-admin-开发一个后台管理——登录 使用-vue-element-admin-开发一个后台管理——首页 使用-vue-element-admin-开发一个后台管理——新建栏目 使用-vue-element-admin-开发一个后台管理——接口联调 使用-vue-element-admin-开发一个后台管理——发布上线 相关文档 vue mockjs element-ui vue-element-admin vue-el-admin-tpl","tags":[{"name":"vue","slug":"vue","permalink":"http://fredwei.com/tags/vue/"},{"name":"admin","slug":"admin","permalink":"http://fredwei.com/tags/admin/"},{"name":"element","slug":"element","permalink":"http://fredwei.com/tags/element/"}]},{"title":"使用 vue-element-admin 开发一个后台管理——登录","date":"2018-03-15T02:37:23.000Z","path":"2018/03/15/使用-vue-element-admin-开发一个后台管理——登录/","text":"在开发的阶段，要一直在服务器环境下进行开发，所以要先执行npm run dev启动本地虚拟服务，接着就可以愉快的敲代码了。 登录在登录这一块使用到token验证，获取token及用户信息流程如下： （前端）进入登录页面 —— \\src\\views\\login\\login.vue|（前端）输入账号密码，发起登录请求 —— \\src\\views\\login\\login.vue|（后端）校验账号密码，返回token —— \\src\\mock\\login.js|（前端）获取token，存入cookie，发起获取用户信息请求 —— \\src\\permissiom.js|（后端）校验token，是否有效或者过期，正常则返回用户权限等信息 —— \\src\\mock\\login.js|（前端）获取用户信息，存入state，跳转首页 —— \\src\\permissiom.js 以上流程只列出主要文件，各个文件所引用到的其他模块没有一一列出，详情请看源码 特别说明：本地开发时使用mock来进行数据模拟，所以后端的两次操作在开发阶段都在\\src\\mock\\login.js中进行处理token存储在浏览器cookie，页面刷新不清除用户信息存储在应用state中，页面刷新会重新获取 另外，在页面间跳转时路由都会进行拦截，判断是否已存在token及用户信息，如果没有则会跳转登录页面，具体处理在\\src\\permissiom.js文件中。 登录页的相关文件目录如下：视图 \\src\\views\\login\\接口 \\src\\api\\login.js路由拦截 \\src\\permissiom.js模拟数据 \\src\\mock\\login.js 系列文章 使用-vue-element-admin-开发一个后台管理——初始化 使用-vue-element-admin-开发一个后台管理——接口约定 使用-vue-element-admin-开发一个后台管理——mock数据 使用-vue-element-admin-开发一个后台管理——国际化 使用-vue-element-admin-开发一个后台管理——登录 使用-vue-element-admin-开发一个后台管理——首页 使用-vue-element-admin-开发一个后台管理——新建栏目 使用-vue-element-admin-开发一个后台管理——接口联调 使用-vue-element-admin-开发一个后台管理——发布上线 相关文档 vue mockjs element-ui vue-element-admin vue-el-admin-tpl","tags":[{"name":"vue","slug":"vue","permalink":"http://fredwei.com/tags/vue/"},{"name":"admin","slug":"admin","permalink":"http://fredwei.com/tags/admin/"},{"name":"element","slug":"element","permalink":"http://fredwei.com/tags/element/"}]},{"title":"使用 vue-element-admin 开发一个后台管理——国际化","date":"2018-03-15T02:33:29.000Z","path":"2018/03/15/使用-vue-element-admin-开发一个后台管理——国际化/","text":"vue-element-admin的默认语言是英文，在这里我已经把默认语言改成中文了，需要修改的地方比较分散，在这里不展开来讲。 国际化国际化方案有很多，在该项目中是以js文件作为配置文件，并且在全局使用；语言包在\\src\\lang\\文件中，默认使用中文，即调用\\src\\lang\\zh.js，语言文件如下所示： 12345678910111213141516export default &#123; route: &#123; home: '首页', news: '新闻', ... &#125;, navbar: &#123; logOut: '退出登录', ... &#125;, login: &#123; title: '系统登录', ... &#125; ...&#125; 在使用后台管理系统过程中，可以随时切换，增加新的字段时，记得在两个语言包中同时添加，以免进行语言切换后找不到对应的文字。 具体使用方法如下： 在视图文件的template中使用时，直接调用$t(&#39;键名&#39;)，例如: 123&lt;template&gt; &lt;h3 class=\"title\"&gt;&#123;&#123;$t('login.title')&#125;&#125;&lt;/h3&gt;&lt;/template&gt; 可以在视图文件的script中调用，例如: 1234&lt;script&gt; const _titleText = this.$t('login.title') console.log('login.title对应语言包中的文字是：' + _titleText)&lt;/script&gt; 系列文章 使用-vue-element-admin-开发一个后台管理——初始化 使用-vue-element-admin-开发一个后台管理——接口约定 使用-vue-element-admin-开发一个后台管理——mock数据 使用-vue-element-admin-开发一个后台管理——国际化 使用-vue-element-admin-开发一个后台管理——登录 使用-vue-element-admin-开发一个后台管理——首页 使用-vue-element-admin-开发一个后台管理——新建栏目 使用-vue-element-admin-开发一个后台管理——接口联调 使用-vue-element-admin-开发一个后台管理——发布上线 相关文档 vue mockjs element-ui vue-element-admin vue-el-admin-tpl","tags":[{"name":"vue","slug":"vue","permalink":"http://fredwei.com/tags/vue/"},{"name":"admin","slug":"admin","permalink":"http://fredwei.com/tags/admin/"},{"name":"element","slug":"element","permalink":"http://fredwei.com/tags/element/"}]},{"title":"使用 vue-element-admin 开发一个后台管理——mock数据","date":"2018-03-15T02:28:26.000Z","path":"2018/03/15/使用-vue-element-admin-开发一个后台管理——mock数据/","text":"自从有了前后端分离的概念，前端模拟数据这一块就出了很多方案，mock无疑是一个很好的选择。 mock数据接口约定好了之后，前端可以使用mock来模拟后端接口返回的数据，做到前后分离并行开发。 假设登录页面需要一个登录接口/login/login，接口的处理以及生成mock数据流程如下： (1) 在\\src\\api\\目录新建一个login.js文件，用于处理所有登录相关的接口，文件示例如下：123456789101112// 引入request组件，处理所有ajax请求import request from '@/utils/request'// 设置一个方法名为loginByUsername，传入的参数是账号及密码export function loginByUsername(query) &#123; // 获取token return request(&#123; url: '/login/login', method: 'post', params: query &#125;)&#125; (2) 在\\src\\mock\\目录新建一个login.js文件，用于模拟所有登录相关的数据，文件示例如下：12345678910111213141516171819202122232425262728293031// 如果需要使用Mock生成随机结果，则需要引入Mock模块，文档见 http://mockjs.com/// import Mock from 'mockjs'// 引入param2Obj模块用于处理传入的参数import &#123; param2Obj &#125; from '@/utils'export default &#123; // 登录请求处理 loginByUsername: config =&gt; &#123; const &#123; username &#125; = param2Obj(config.url) if (username) &#123; return &#123; status: 200, message: '登录成功', data: &#123; roles: ['admin'], token: 'admin_token_12345', introduction: '我是超级管理员', avatar: 'https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif', name: 'Super Admin' &#125; &#125; &#125; else &#123; return &#123; status: 2002, message: '登录失败', data: null &#125; &#125; &#125;&#125; (3) 在\\src\\mock\\目录建好login.js文件，还需要在\\src\\mock\\index.js中将该文件注册，否则无法访问，文件示例如下：12345678910111213141516// 引入Mock模块import Mock from 'mockjs'// 引入login文件import loginAPI from './login'// 模拟接口延迟响应// Mock.setup(&#123;// timeout: '350-600'// &#125;)// 登录相关（接口地址与模拟数据的方法名称一一对应）Mock.mock(/\\/login\\/login/, 'post', loginAPI.loginByUsername)Mock.mock(/\\/login\\/logout/, 'post', loginAPI.logout)Mock.mock(/\\/user\\/info\\.*/, 'get', loginAPI.getUserInfo)// 等等... (4) 写好接口文件及mock数据，那么接下来就可以在视图文件中使用了，示例如下： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt;...&lt;/template&gt;&lt;script&gt;// 引入该页面需要调用的接口方法名称import &#123; loginByUsername &#125; from '@/api/login'export default &#123; name: 'login', components: &#123; ... &#125;, data() &#123; return &#123; ... &#125; &#125;, methods: &#123; // 登录 handleLogin() &#123; loginByUsername(&#123; username: 'admin', password: '12345678' &#125;).then(response =&gt; &#123; console.log('处理登录请求成功返回结果') &#125;).catch((error) =&gt; &#123; console.log('处理登录请求失败返回结果') &#125;) &#125; ... &#125;&#125;&lt;/script&gt; 系列文章 使用-vue-element-admin-开发一个后台管理——初始化 使用-vue-element-admin-开发一个后台管理——接口约定 使用-vue-element-admin-开发一个后台管理——mock数据 使用-vue-element-admin-开发一个后台管理——国际化 使用-vue-element-admin-开发一个后台管理——登录 使用-vue-element-admin-开发一个后台管理——首页 使用-vue-element-admin-开发一个后台管理——新建栏目 使用-vue-element-admin-开发一个后台管理——接口联调 使用-vue-element-admin-开发一个后台管理——发布上线 相关文档 vue mockjs element-ui vue-element-admin vue-el-admin-tpl","tags":[{"name":"vue","slug":"vue","permalink":"http://fredwei.com/tags/vue/"},{"name":"admin","slug":"admin","permalink":"http://fredwei.com/tags/admin/"},{"name":"element","slug":"element","permalink":"http://fredwei.com/tags/element/"}]},{"title":"使用 vue-element-admin 开发一个后台管理——接口约定","date":"2018-03-15T02:27:01.000Z","path":"2018/03/15/使用-vue-element-admin-开发一个后台管理——接口约定/","text":"约定接口往往是项目开始之前要做的事情，当然实际是很多时候都是边写边确定，只有数据格式约定好，那么后续的开发就可以做到两翼齐飞了~ 接口约定前后端接口要约定好请求及返回格式，以便双方可以并行开发，提高开发效率。 请求及返回的拦截都在\\src\\utils\\request.js中进行处理 请求时，每个请求头都带上token 123456789101112131415// \\src\\utils\\request.js// 请求拦截器service.interceptors.request.use(config =&gt; &#123; // 请求拦截操作 if (store.getters.token) &#123; // 让每个请求携带token-- ['X-Token']为自定义key 请根据实际情况自行修改 config.headers['X-Token'] = getToken() &#125; return config&#125;, error =&gt; &#123; // 请求拦截报错 console.log(error) Promise.reject(error)&#125;) 请求的数据格式为json格式，如： 12345678getSomeDate(&#123; id: '123123', status: 1&#125;).then(response =&gt; &#123; // 请求成功，处理成功结果&#125;).catch(() =&gt; &#123; // 请求失败，处理失败结果&#125;) 返回的格式也是json格式，如下： 12345678&#123; status: 200, message: '数据获取成功', data: &#123; total: 100, items: [1,2,..., 100] &#125;&#125; status是状态码，vue-el-admin-tpl中约定200是正常返回，也可以与后台约定好，在\\src\\utils\\request.js修改状态码的封装处理即可 1234567891011121314151617// \\src\\utils\\request.js// 50008:非法的token// 50012:其他客户端登录了// 50014:Token 过期了if (res.status === 50008 || res.status === 50012 || res.status === 50014) &#123; this.$msgbox.confirm('你已被登出，可以取消继续留在该页面，或者重新登录', '确定登出', &#123; confirmButtonText: '重新登录', cancelButtonText: '取消', type: 'warning' &#125;).then(() =&gt; &#123; store.dispatch('FedLogOut').then(() =&gt; &#123; // 为了重新实例化vue-router对象 避免bug location.reload() &#125;) &#125;)&#125; 系列文章 使用-vue-element-admin-开发一个后台管理——初始化 使用-vue-element-admin-开发一个后台管理——接口约定 使用-vue-element-admin-开发一个后台管理——mock数据 使用-vue-element-admin-开发一个后台管理——国际化 使用-vue-element-admin-开发一个后台管理——登录 使用-vue-element-admin-开发一个后台管理——首页 使用-vue-element-admin-开发一个后台管理——新建栏目 使用-vue-element-admin-开发一个后台管理——接口联调 使用-vue-element-admin-开发一个后台管理——发布上线 相关文档 vue mockjs element-ui vue-element-admin vue-el-admin-tpl","tags":[{"name":"vue","slug":"vue","permalink":"http://fredwei.com/tags/vue/"},{"name":"admin","slug":"admin","permalink":"http://fredwei.com/tags/admin/"},{"name":"element","slug":"element","permalink":"http://fredwei.com/tags/element/"}]},{"title":"使用 vue-element-admin 开发一个后台管理——初始化","date":"2018-03-12T03:41:12.000Z","path":"2018/03/12/使用-vue-element-admin-开发一个后台管理——初始化/","text":"在学习和使用vue-element-admin过程中遇到蛮多的问题的，主要是模板跟业务相关性有所出入，熟悉及调整的时候花费了不少时间。基于vue-element-admin进行二次开发，产出vue-el-admin-tpl。 这一系列的教程只针对有一些vue开发基础的童鞋，篇幅有限，教程有很多细节的不会展开来说。 初始化1、下载到本地1git clone git@github.com:fredwei/vue-el-admin-tpl.git 2、进入目录1cd vue-el-admin-tpl 3、安装项目需要的依赖1234npm install// 推荐使用国内淘宝镜像npm install --registry=https://registry.npm.taobao.org 4、开发及发布12345678# 构建本地环境npm run dev# 构建测试环境npm run build:sit# 构建生产环境npm run build:prod 还有一个补充点就是，项目使用了eslint作为代码规范约束，但是开发过程中有时候一些空格或者分号等小问题很多，一个个手动修改实在太麻烦，那么有一个命令可以帮你解决额这个问题，在命令窗口下输入： 12# 进行代码规范校验并修复npm run lint --fix 如果有一些重要的错误无法自动修复，那么就需要手动修改了，错误提示会详细的指出是哪个文件，哪一行，是什么规则的校验没有通过，还有链接可以点开前往查看该规则的详细介绍，示例如下： 123456789101112131415 http://eslint.org/docs/rules/semi Extra semicolon src\\main.js:29:32 Vue.filter(key, filters[key]); ^ 1 problem (1 error, 0 warnings)Errors: 1 http://eslint.org/docs/rules/semiYou may use special comments to disable some warnings.Use // eslint-disable-next-line to ignore the next line.Use /* eslint-disable */ to ignore all warnings in a file. 表示在\\src\\main.js这个文件的第29行第32个字符，多了一个分号，校验的规则地址是http://eslint.org/docs/rules/semi。 以上只是简单的讲述了一下从下载模板到打包构建完成的一个流程，下边会细讲开发及打包发布的事项。 注意事项： 在最后联调的时候修改\\config目录下对应的配置文件，对应各个环境的接口，记得去掉mock模拟数据（在\\src\\main.js中，去掉import &#39;./mock&#39;） 新增、删除、修改文件时，应用会自动构建并刷新浏览器，如无法正常访问，请在命令窗口输入ctrl+c停止本地服务器，然后输入npm run dev重新启动 发现这个项目在windows下ctrl+c不能完全停止本地虚拟服务器，不知道是不是个例；如果遇到同样的情况，直接在任务管理器，结束进程node.exe。（不能停止表现为，npm run dev启动服务时，端口与配置文件中不一致，进程中会有多个node进程） 系列文章 使用-vue-element-admin-开发一个后台管理——初始化 使用-vue-element-admin-开发一个后台管理——接口约定 使用-vue-element-admin-开发一个后台管理——mock数据 使用-vue-element-admin-开发一个后台管理——国际化 使用-vue-element-admin-开发一个后台管理——登录 使用-vue-element-admin-开发一个后台管理——首页 使用-vue-element-admin-开发一个后台管理——新建栏目 使用-vue-element-admin-开发一个后台管理——接口联调 使用-vue-element-admin-开发一个后台管理——发布上线 相关文档 vue mockjs element-ui vue-element-admin vue-el-admin-tpl","tags":[{"name":"vue","slug":"vue","permalink":"http://fredwei.com/tags/vue/"},{"name":"admin","slug":"admin","permalink":"http://fredwei.com/tags/admin/"},{"name":"element","slug":"element","permalink":"http://fredwei.com/tags/element/"}]},{"title":"hexo本地开发时默认的4000端口无法访问","date":"2017-12-29T08:56:31.000Z","path":"2017/12/29/hexo本地开发时默认的4000端口无法访问/","text":"好久没有写博客，事情的起因是这样的： 今天在阿里云买了个新域名，然后进行备案，巴拉巴拉一切资料提交之后，等待审核。 阿里的速度还是很快的，下午的时候就来电话了，跟我说我的博客底部没有备案号…… 于是乎，重新打开博客项目，命令全忘光了，赶紧百度一下，嗯嗯，找到底部代码footer.ejs修改完毕，输入hexo s启动本地服务看看效果。 然而打开http://localhost:4000/死活没反应，命令行也无错误提示，怎么回事？ 速度百度，查到原因了，原来是端口被占用，修改端口重启启动，分分钟解决问题。 12// 启动hexo服务，设置端口为5000hexo s -p 5000 然而这个是临时修改，最后还是在配置文件中把端口配置好，免得每次都要输入。 打开_confit.yml配置文件： 123# serverserver: port: 5000 大功告成了 ，开心的玩耍吧~ 参考：温浩然的博客参考：segmentfault的答案","tags":[{"name":"hexo","slug":"hexo","permalink":"http://fredwei.com/tags/hexo/"}]},{"title":"Web Worker","date":"2017-05-25T04:26:19.000Z","path":"2017/05/25/workers/","text":"总所周知，javascript是单线程的，当一个函数执行的时候，JS引擎会锁住DOM树，其他事件的响应代码只能在队列中等待，并且此时页面卡死。如果某些脚本比较复杂、耗时，那么将会阻塞javascript继续执行，甚至导致浏览器失去响应。那么要实现javascript的多线程，ajax异步请求可以开辟一个新的线程来处理请求的业务，并不是真正意义上的多线程。在HTML5中，引入了Web Worker这个概念，它能够在另外一个线程中执行计算密集的JS代码而不引起页面卡死，这是真正的多线程。 一、setTimeout和setInterval使用定时器看似是可以多个事件同时处理，其实并非是多线程的。 定时器只是一个定时的事件触发器，它们在合适的时间把一些JS代码塞到JS引擎的队列中，然后JS会逐个处理队列中的事件。 二、Web Worker 简介在HTML5中，引入了Web Worker这个概念。它能够在另外一个线程中执行计算密集的JS代码而不引起页面卡死，这是真正的多线程。然而为了保证线程安全，Worker中的代码是不能访问DOM的。具体解释请看火狐开发文档-Worker 官方的解释：Web Workers是一种机制，通过它可以使一个脚本操作在与Web应用程序的主执行线程分离的后台线程中运行。这样做的优点是可以在单独的线程中执行繁琐的处理，让主（通常是UI）线程运行而不被阻塞/减慢。 特别提醒，运行worker多线程，需要在服务器环境下，所以在跑一下demo时，请自行搭建运行环境。 三、Worker基本用法首先，先了解下worker常用的两个方法onmessage和postMessage，onmessage是监听worker文件返回数据的回调方法，postMessage是worker返回页面的数据的方法。示例如下： 页面文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;button id=\"btn1\"&gt;有worker&lt;/button&gt;&lt;button id=\"btn2\"&gt;无worker&lt;/button&gt;&lt;div id=\"time\"&gt;&lt;/div&gt;&lt;div id=\"output\" style=\"height: 400px; border: 1px solid #ccc; overflow-y: auto; word-break: break-all;\"&gt;&lt;/div&gt;&lt;script&gt;if(typeof(Worker) !== \"undefined\")&#123; // var _worker = new Worker('demo2.js');&#125;function workerInit()&#123; if(typeof(Worker) !== \"undefined\")&#123; var _html = []; var _worker = new Worker('demo2.js'); _worker.onmessage = function(event) &#123; if(event.data.n)&#123; _html.push(event.data.n); &#125; if(event.data.t)&#123; document.getElementById('output').innerHTML = _html.join(','); document.getElementById('time').innerHTML = '耗时：' + (new Date().getTime() - event.data.t + '毫秒'); &#125; &#125; &#125;else&#123; alert('不支持 Worker'); &#125;&#125;var btn1 = document.getElementById('btn1');var btn2 = document.getElementById('btn2');btn1.onclick = workerInit;btn2.onclick = function()&#123; var n = 1; var _t = new Date().getTime(); var _h = []; abc:while(n &lt; 99999)&#123; ++n; // 查找质数（在大于1的自然数中，除了1和该整数自身外，无法被其他自然数整除的数） for (var i = 2; i &lt;= Math.sqrt(n); i++) &#123; if(n%i == 0)&#123; continue abc; &#125; &#125; _h.push(n); &#125; document.getElementById('output').innerHTML = _h.join(','); document.getElementById('time').innerHTML = '耗时：' + (new Date().getTime() - _t + '毫秒');&#125;;&lt;/script&gt; tips:发现个奇怪的问题，如上代码第9行，在外部定义了worker之后，在workerInit方法中无法正常调用，而且并没有报错。 worker文件demo2.js：1234567891011121314151617181920212223var n = 1;var _t = new Date().getTime();search:while(n &lt; 99999)&#123; ++n; // 查找质数（在大于1的自然数中，除了1和该整数自身外，无法被其他自然数整除的数） for (var i = 2; i &lt;= Math.sqrt(n); i++) &#123; if(n%i == 0)&#123; continue search; &#125; &#125; // console.log(new Date().getTime() - _t, n); // document.getElementById('output').innerHTML += (n + '，'); postMessage(&#123; n: n &#125;);&#125;postMessage(&#123; t: _t&#125;); 以上代码中，在1-99999中查找质数，每找到一个，使用postMessage返回一次，循环结束后，返回循环开始的时间。 应用worker与原生js处理相同业务所需的时间是多少呢？应用worker五次运行分别耗时（平均204.8ms）：204ms，216ms，197ms，208ms，199ms原生js五次运行分别耗时（平均32.4ms）：40ms，38ms，24ms，32ms，28ms 以执行速度来看，查找1-99999中的质数，原生js比worker快大约6倍 当然这并不意味这worker是个无用的功能，在某些应用场景还是很适用的。 最后worker除了onmessage和postMessage这两个方法，还有其他的约束及api，具体请自行查看文档火狐开发文档-Worker 四、兼容问题无法避免的兼容问题，除了worker对象的兼容，还有worker api的兼容也各不同，以下是worker对象的兼容。 桌面端： Feature Chrome Firefox (Gecko) Internet Explorer Opera Safari (WebKit) Basic support 4 3.5 10.0 10.6 4 移动端： Feature Android Firefox Mobile (Gecko) Firefox OS (Gecko) IE Phone Opera Mobile Safari Mobile Basic support 4.4 3.5 1.0.1 10.0 11.5 5.1","tags":[{"name":"html5","slug":"html5","permalink":"http://fredwei.com/tags/html5/"},{"name":"workers","slug":"workers","permalink":"http://fredwei.com/tags/workers/"},{"name":"web api","slug":"web-api","permalink":"http://fredwei.com/tags/web-api/"}]},{"title":"在 github pages 添加自定义域名","date":"2017-05-12T03:16:22.000Z","path":"2017/05/12/添加自定义域名/","text":"在github上搭建静态页面博客，会得到一个可在线访问的地址，例如我的博客地址是fredwei.github.io。 显然这个地址比较难记，不过github允许用户绑定自定义域名。 一、首先，你的搭建好你的博客我使用的是hexo在github上搭建的个人博客，当然你也可以用其他的，但是最终上传到github上的内容基本上是一直的，如下图： 绑定自定义域名的前提是，你已经把博客已经搭建好了。如果还不知道怎么搭建博客，可以参考这里hexo搭建教程或者hexo官网 二、拿到博客的IP地址打开命令行工具，ping一下github给到的博客地址，拿到一个ip地址，如ping fredwei.github.io 三、将你的域名解析到这个IP地址如果是域名解析的记录类型是A，那么就指向IP 如果是CNAME，那么就指向你的博客域名（如fredwei.github.io），相当于重定向，这里不做演示。 四、添加CNAME文件一般来讲，域名解析到指定的IP，就可以通过域名访问该网站了。然而在github上还需要做一步操作，就是添加CNAME文件（无后缀名）。 文件的内容很简单，就是你的域名 1www.fredwei.com 五、完成最后一步当然是上传到github上了，使用hexo的一个命令hexo d，上传成功后，即可通过域名访问到你的博客了。 如果没有用hexo，那就自行上传吧。 收工~","tags":[{"name":"github","slug":"github","permalink":"http://fredwei.com/tags/github/"},{"name":"github pasges","slug":"github-pasges","permalink":"http://fredwei.com/tags/github-pasges/"},{"name":"cname","slug":"cname","permalink":"http://fredwei.com/tags/cname/"}]},{"title":"vuejs基础入门","date":"2017-04-26T02:34:00.000Z","path":"2017/04/26/vuejs基础入门/","text":"为什么要学习vuejs？因为这两年vuejs蛮火的，而且易入门，实用。vuejs 是一套构建用户界面的 渐进式框架。vuejs 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。vuejs 现在不支持IE8及以下，以后也不会支持。 一、基本语法1、插值1.1 文本双大括号包裹住变量名1&lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; 1.2 纯HTML使用v-html指令输出html1&lt;div v-html=\"message\"&gt;&lt;/div&gt; 1.3 属性使用v-bind指令绑定dom元素属性1&lt;div v-bind:id=\"message\" v-bind:data-abc=\"message\"&gt;&lt;/div&gt; 1.4 JavaScript 表达式使用双大括号包裹住表达式1234&lt;p&gt;&#123;&#123; number + 1 &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/p&gt;&lt;p v-bind:id=\"'list-' + id\"&gt;&lt;/p&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。类似于一个function，执行一系列语句后，必须 return 一个结果。 1234&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 不应该在模板表达式中试图访问用户定义的全局变量 2、指令指令（Directives）是带有 v- 前缀的特殊属性 2.1 参数如下：url和doSomething就是传入vue实例的参数，url是一个变量，doSomething是一个方法名12&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;a v-on:click=\"doSomething\"&gt; 2.2 修饰符修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定.prevent修饰符告诉v-on指令对于触发的事件调用event.preventDefault()来阻止默认行为1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt; 事件修饰符有：.stop``.prevent``.capture``.self``.once更多修饰符自己查.. 3、过滤器vuejs 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：插值和v-bind表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示 1234&lt;!-- in 插值 --&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;!-- in v-bind --&gt;&lt;div v-bind:id=\"rawId | formatId\"&gt;&lt;/div&gt; 123456789101112new Vue(&#123; // ... filters: &#123; // 自定义过滤器 // 过滤器函数总接受表达式的值作为第一个参数 capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;) 过滤器可以串联12&lt;!-- 多个过滤器 --&gt;&#123;&#123; message | filterA | filterB &#125;&#125; 过滤器可以接受参数1&#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 字符串&#39;arg1&#39;将传给过滤器作为第二个参数，arg2表达式的值将被求值然后传给过滤器作为第三个参数 4、缩写v-前缀在模板中是作为一个标示 Vue 特殊属性的明显标识，整个应用都使用vuejs的话，那么前缀v-就没有那么重要123456789&lt;!-- v-bind 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;&lt;/a&gt;&lt;!-- v-bind 缩写 --&gt;&lt;a :href=\"url\"&gt;&lt;/a&gt;&lt;!-- v-on 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt;&lt;!-- v-on 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 实际是，不用缩写也是挺好的。 二、基本用法在学习之前，先把vuejs下载下来放在本地，直接使用script标签引入即可。 1、声明式渲染1&lt;div id=\"app\"&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: '#app', data: &#123; message: '你好，程序猿！' &#125;&#125;) 结果输出：你好，程序猿！ 2、绑定 DOM 元素属性123&lt;div id=\"app-2\"&gt; &lt;span v-bind:title=\"message\" v-bind:data-alt=\"message\"&gt;鼠标移动到我上边来&lt;/span&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: '#app-2', data: &#123; message: '什么都没有' &#125;&#125;) 生成HTML：1&lt;div id=\"app-2\"&gt;&lt;span title=\"什么都没有\" data-alt=\"什么都没有\"&gt;鼠标移动到我上边来&lt;/span&gt;&lt;/div&gt; 3、if语句1234&lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;看得见我&lt;/p&gt; &lt;p v-if=\"!seen\"&gt;看不见我&lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;) 在命令行改变app3.seen的值，会看到页面内容的变化 4、for循环1234567&lt;div id=\"app-4\"&gt; &lt;ol&gt; &lt;li v-for=\"item in todos\"&gt; &#123;&#123; item.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: '#app-4', data: &#123; todos: [ &#123; text: '不要学 JavaScript' &#125;, &#123; text: '不要学 Vue' &#125;, &#123; text: '什么都不要学' &#125; ] &#125;&#125;) 生成HTML：12345&lt;ol&gt; &lt;li&gt;不要学 JavaScript&lt;/li&gt; &lt;li&gt;不要学 Vue&lt;/li&gt; &lt;li&gt;什么都不要学&lt;/li&gt;&lt;/ol&gt; 5、v-on监听事件1234&lt;div id=\"app-5\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"toChange\"&gt;点我点我点我&lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: '#app-5', data: &#123; message: '我是一串很长的字符串' &#125;, methods: &#123; toChange: function () &#123; this.message = this.message.split('').reverse().join(''); &#125; &#125;&#125;) 点击按钮，文字会经过toChange方法处理，进行逆序并输出 6、v-model指令在表单输入和应用状态中做双向数据绑定 1234&lt;div id=\"app-6\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=\"message\"&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: '#app-6', data: &#123; message: '写点什么好呢' &#125;&#125;) 改变输入框的值，或者在控制台改变app6.message的值，页面中的文本及输入框的值都会同时改变 三、组件将vuejs应用到开发中，组件是必不可少的部分。 1234567&lt;div id=\"app-7\"&gt; &lt;ol&gt; &lt;todo-item v-for=\"item in list\" v-bind:ccc=\"item\"&gt;&lt;/todo-item&gt; &lt;li v-for=\"item in list\"&gt;2&#123;&#123; item.text &#125;&#125;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 上段代码中，ccc相当于function中接收到的形参，作用于function内部1234567891011121314151617// 定义组件Vue.component('todo-item', &#123; props: ['ccc'], template: '&lt;li&gt;&#123;&#123; ccc.text &#125;&#125;&lt;/li&gt;'&#125;)// vue实例var app7 = new Vue(&#123; el: '#app-7', data: &#123; list: [ &#123; text: '不要学 JavaScript' &#125;, &#123; text: '不要学 Vue' &#125;, &#123; text: '什么都不要学' &#125; ] &#125;&#125;) 以上代码执行后发现，使用组件输出与直接用for循环输出，结果是一致的，但使用组件有更多的可控性 四、总结不需要关注页面dom的操作，只需要管理页面数据即可！","tags":[{"name":"vuejs","slug":"vuejs","permalink":"http://fredwei.com/tags/vuejs/"}]},{"title":"h5唤醒App","date":"2017-04-13T05:37:37.000Z","path":"2017/04/13/h5唤醒App/","text":"首先要声明的一点是，h5页面无法获取app的状态，也就是说，无法判断app是否已下载，app是否已打开。那么基于这个，怎么样实现在h5页面唤醒指定的app呢？请看下回分解~ 一般来讲，app产品都会有一个下载落地页，引导用户前往应用市场下载app应用，安卓的前往安卓市场，ios的跑到appstore。那么先不考虑页面的样式，首先进入到页面，第一步是获取设备信息，也就是浏览器信息。 1、获取设备信息12345678910111213141516171819202122function getPlatform()&#123; var u = navigator.userAgent, app = navigator.appVersion, iosVer = app.match(/OS (\\d+)_(\\d+)_?(\\d+)?/); return &#123; // android终端或者uc浏览器 android: u.indexOf('Android') &gt; -1 || u.indexOf('Linux') &gt; -1, // 是否为iPhone或者QQHD浏览器 iPhone: u.indexOf('iPhone') &gt; -1, // 是否iPad iPad: u.indexOf('iPad') &gt; -1, // ios 版本号 iosVer: iosVer &amp;&amp; parseInt(iosVer[1], 10), // 微信 weChat: u.indexOf('MicroMessenger') &gt; -1, // QQ QQ: u.indexOf('QQ') &gt; -1, // 微博 WeiBo: u.indexOf('weibo') &gt; -1 &#125;;&#125; 2、设置app下载地址安卓应用市场及appstore下载地址各不相同，所以要跟app的童鞋拿到应用下载地址123// 下载链接var _androidUrl = 'http://a.app.qq.com/o/simple.jsp?pkgname=com.ingdan.ingdannews';var _iosUrl = 'https://itunes.apple.com/us/app/in-tou-tiao-zhuan-zhu-zhi/id1197794545?l=zh&amp;ls=1&amp;mt=8'; 3、跳转app下载页面那么页面打开后，就应该判断设备，然后进行页面跳转了1234567891011var _platform = getPlatform();var _downloadUrl = _androidUrl;if(_platform.android)&#123; // 安卓&#125;else&#123; // ios _downloadUrl = _iosUrl;&#125;window.location.href = _downloadUrl; 是不是很完美了，当然不是，app还没打开呢，而且在各个不同环境有不同限制，例如在微信或微博中打开，是不允许直接跳转到appstore，那怎么解决？12345678if(_platform.android)&#123; // 安卓&#125;else&#123; // ios if(_platform.weChat || _platform.WeiBo)&#123; alert('请再浏览器中打开本页面~速去'); &#125;&#125; 看起来十分完美，然而还是没有，app也还没打开呢 4、打开APP如何打开app呢，这里需要注意的一点事，打开app必须要开发的童靴提供一个自定义协议，例如： 1var _appUrl = 'INNewsApp://'; 其中INNewsApp://是app开发自行决定的协议，当然最好后边能跟上app相对应的域名，如：INNewsApp://m.ingdan.com如果需要打开app后跳转到指定页面，那么就应该在链接中加入参数，如：INNewsApp://m.ingdan.com?id=9527 打来app地址有了，接下来如何处理？我们这里使用iframe来打开，避免了一旦url有误，或者手机上没有安装app导致报错。 1234567// 在iframe 中打开APPvar ifr = document.createElement('iframe');ifr.style.display = 'none';ifr.src = _appUrl;document.body.appendChild(ifr); 到了这时，在测试ios的时候发现一个问题，ios9以上，不支持iframe打开app于是乎1234567// 判断ios版本，ios9以上直接打开if(_platform.iosVer &gt;= 9)&#123; window.location.href = _appUrl;&#125;else&#123; // 在iframe 中打开APP // ...&#125; 如果手机上安装有app，这是h5就可以唤醒app，app就启动了。 5、一些兼容处理产品这时希望，那么如果手机上没有安装app，怎跳转到app下载页面，怎么办？先把产品打一顿再说 1234567setTimeout(function() &#123; // 2秒之后，移除iframe document.body.removeChild(ifr); // 跳转到app下载地址 window.location.href = _downloadUrl;&#125;, 2000); 这样似乎已经完美了，然后还没有。一般情况下，浏览器处于非激活状态、使用alert弹出信息或者系统信息提示，页面是会中断js运行的然后在QQ安卓版的内置浏览器上，并没有，更为让人开心的是，如果你的app是跳转到应用宝上，应用宝会自动判断你是否一下子该app，并且还很友好的帮你打开这个时候你就会发现，在QQ内置浏览器打开下载引导页面，app打开了，正看得高兴，过了2秒，app又打开一次… 于是乎1234// 非QQ内置浏览器if(!_platform.QQ)&#123; window.location.href = _downloadUrl;&#125; 那在QQ安卓版的内置浏览器上，如果有app，则自动打开，如果没有，怎么引导用户下载？页面上那么大一颗下载按钮，自己点吧。","tags":[]},{"title":"使用webpack构建时给window绑定事件的坑","date":"2017-03-28T07:45:25.000Z","path":"2017/03/28/使用webpack构建时给window绑定事件的坑/","text":"使用webpack进行构建，给window绑定了onload的事件，结果竟然死活不触发！各种排除后发现问题所在… 业务js文件index.js 12345678var $ = require('jquery');$(function()&#123; // 在这里绑定，无效 $(window).on('load', function()&#123; console.log('页面加载完成了~'); &#125;);&#125;) 打开页面，然后控制台并没有打印出“页面加载完成了~” 难道是使用jquery进行绑定的原因导致事件绑定无效？于是改了代码： 12345678var $ = require('jquery');$(function()&#123; // 在这里绑定，还是无效 window.onload = function()&#123; console.log('页面加载完成了~'); &#125;;&#125;) 控制台依然没有打印出预期的结果，苦思良久，改成 123456789101112131415var $ = require('jquery');// 在这里绑定，有效$(window).on('load', function()&#123; console.log('页面加载完成了~ 1');&#125;);// 在这里绑定，也有效window.onload = function()&#123; console.log('页面加载完成了~ 2');&#125;;$(function()&#123; &#125;) 那看来是’$(function(){})’这一段代码的问题了，这段代码并不难理解，当页面的dom结构加载完毕则执行，刚入门是使用’script’标签引入jquery，并没有这样的问题出现。 那么现在看来是使用webpack进行构建的并发症了，至于原因，并没有深究的意愿。 现在页面的js基本都是放在页面底部，程序执行到这里，其实意味着dom结构以及渲染完毕了，个人觉得在js中写’$(function(){})’是没有必要了的","tags":[{"name":"webpack","slug":"webpack","permalink":"http://fredwei.com/tags/webpack/"},{"name":"jquery","slug":"jquery","permalink":"http://fredwei.com/tags/jquery/"}]},{"title":"使用hexo遇到的一个坑","date":"2017-03-23T03:46:16.000Z","path":"2017/03/23/使用hexo遇到的一个坑/","text":"hexo中首页列表的摘要（excerpt）弄不出来，一直显示全文 修改了N多配置都不生效，官方文档中也没有说明，唯有各种搜索答案，终于找到了！ 原来只需要在文中加入&lt;!-- more --&gt;就可以了，这实在是个大坑！ 12345这就是一个简介&lt;!-- more --&gt; 这里更多的内容 原答案链接","tags":[{"name":"hexo","slug":"hexo","permalink":"http://fredwei.com/tags/hexo/"}]},{"title":"Express路由","date":"2017-03-22T08:11:33.000Z","path":"2017/03/22/express路由/","text":"一、简介 1、Express 是一个基于 Node.js 平台的极简、灵活的web应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 2、丰富的 HTTP 快捷方法和任意排列组合的 Connect 中间件，让你创建健壮、友好的 API 变得既快速又简单。 （ Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架） 3、Express 不对 Node.js 已有的特性进行二次抽象，我们只是在它之上扩展了 Web 应用所需的基本功能。 &nbsp; 二、express环境搭建1、安装nodejs和npm，建议安装淘宝提供的国内镜像cnpm，这样安装比较快 1$ npm install –g cnpm 2、新建一个目录，在目录下执行 1$ cnpm install express --save 3、express环境已经搭建好了 &nbsp; 三、基本路由1、简单版，除了get请求，还有post、put、delete 123456789101112131415161718192021222324252627282930313233343536373839404142var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello World! &lt;a href=\"/news\"&gt;to news&lt;/a&gt;');&#125;);app.get('/news', function (req, res) &#123; res.send('this is news. &lt;a href=\"/\"&gt;back&lt;/a&gt;');&#125;).post('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a post request!', data: req.query &#125;);&#125;).put('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a put request!', data: req.query &#125;);&#125;).delete('/news', function (req, res) &#123; console.log('query：' + req.query); console.log('body：' + req.body); res.send(&#123; code: 'abc123', msg: 'get a delete request!', data: req.query &#125;);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 2、字符匹配模式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465var express = require('express');var app = express();// 路径var _routeStr = ['start'];var _routeList = ['&lt;ol&gt;'];_routeList.push('&lt;li&gt;ab?cd（匹配 acd 和 abcd）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab+cd（匹配 abcd、abbcd、abbbcd等）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab*cd（匹配 abcd、abxcd、abRABDOMcd、ab123cd等）&lt;/li&gt;');_routeList.push('&lt;li&gt;ab(cd)?e（匹配 /abe 和 /abcde）&lt;/li&gt;');_routeList.push('&lt;/ol&gt;');app.all('*', function (req, res, next) &#123; console.log('Accessing：' + new Date()); _routeStr = ['start']; next();&#125;);// 匹配 acd 和 abcdapp.get('/ab?cd', function(req, res, next) &#123; // res.send('ab?cd'); _routeStr.push('ab?cd'); next();&#125;);// 匹配 abcd、abbcd、abbbcd等app.get('/ab+cd', function(req, res, next) &#123; // res.send('ab+cd'); _routeStr.push('ab+cd'); next();&#125;);// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等app.get('/ab*cd', function(req, res, next) &#123; // res.send('ab*cd'); _routeStr.push('ab*cd'); next();&#125;);// 匹配 /abe 和 /abcdeapp.get('/ab(cd)?e', function(req, res, next) &#123; // res.send('ab(cd)?e'); _routeStr.push('ab(cd)?e'); next();&#125;);app.get('*', function(req, res) &#123; _routeStr.push('end'); var _html = '&lt;p&gt;' + _routeStr.join(' ====&gt; ') + '&lt;/p&gt;'; res.send(_routeList.join('') + _html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 3、正则匹配模式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var express = require('express');var app = express();// 路径var _routeStr = ['start'];var _routeList = ['&lt;ol&gt;'];_routeList.push('&lt;li&gt;/a/（匹配任何路径中含有 a 的路径');_routeList.push('&lt;li&gt;/.*fly$/（匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等）&lt;/li&gt;');_routeList.push('&lt;/ol&gt;');app.all('*', function (req, res, next) &#123; console.log('Accessing：' + new Date()); _routeStr = ['start']; next();&#125;);// 匹配任何路径中含有 a 的路径：app.get(/a/, function(req, res, next) &#123; _routeStr.push('/a/'); next();&#125;);// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等app.get(/.*fly$/, function(req, res, next) &#123; _routeStr.push('/.*fly$/'); next();&#125;);app.get('*', function(req, res) &#123; _routeStr.push('end'); var _html = '&lt;p&gt;' + _routeStr.join(' ====&gt; ') + '&lt;/p&gt;'; res.send(_routeList.join('') + _html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 3、执行多个回调 1234567891011121314151617181920212223242526272829303132333435363738var express = require('express');var app = express();// 多个回调函数，需指定执行nextapp.get('/b', function (req, res, next) &#123; console.log('this is function b one'); next();&#125;, function (req, res) &#123; console.log('this is function b two'); res.send('Hello from B!');&#125;);// 多个回调传入，需指定执行next，最后必须有sendvar cb0 = function (req, res, next) &#123; console.log('CB0'); next();&#125;var cb1 = function (req, res, next) &#123; console.log('CB1'); next();&#125;var cb2 = function (req, res) &#123; res.send('Hello from C!');&#125;app.get('/c', [cb0, cb1, cb2]);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); &nbsp; 四、中间件router1、通过require导入各种路由配置文件 12345678910111213141516171819202122var express = require('express');var app = express();var _router1 = require('./router/r1.js');var _router2 = require('./router/r2.js');var _router3 = require('./router/r3.js');var _router4 = require('./router/r4.js');app.use('/', _router1);app.use('/r2', _router2);app.use('/r3', _router3);app.use('/r4', _router4);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); 2、简单版 1234567891011121314151617181920var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 定义网站主页的路由router.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// 定义 about 页面的路由router.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 3、通过路由中间件控制 1234567891011121314151617181920212223242526272829303132333435363738var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息router.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 一个中间件栈，处理指向 /user/:id 的 GET 请求router.get('/user/:id', function (req, res, next) &#123; console.log(req.params, req.params.id == 0); // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0)&#123; res.send('ID：' + req.params.id); &#125; // 负责将控制权交给栈中下一个中间件 else&#123; next(); &#125;&#125;, function (req, res, next) &#123; // 渲染常规页面 res.send('next function ID：' + req.params.id); // 填到下一个路由 // next();&#125;);module.exports = router; 使用router.param 123456789101112131415161718192021222324252627282930var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);var _pid;router.get('/blog/:pid', function (req, res, next) &#123; console.log('get function');&#125;);router.param('pid', function (req, res, next, pid)&#123; console.log('param function'); // console.log(req.query); setTimeout(function()&#123; _pid = pid; res.send('my pid is：' + pid + '&amp;&amp;' + req.query.id); &#125;, 1000); next();&#125;);module.exports = router; 多个参数的情况下 12345678910111213141516171819202122232425262728293031323334353637var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 无效，可能是版本问题// router.param(['id', 'page'], function (req, res, next, value) &#123;// console.log('CALLED ONLY ONCE with', value);// next();// &#125;)router.param('nid', function (req, res, next, value) &#123; console.log('nid：', value); next();&#125;);router.param('page', function (req, res, next, value) &#123; console.log('page：', value); next();&#125;);router.get('/news/:nid/:page', function (req, res, next) &#123; console.log('although this matches'); next();&#125;);router.get('/news/:nid/:page', function (req, res) &#123; console.log('and this matches too'); res.send('ok');&#125;);module.exports = router; &nbsp; 五、静态资源目录也算是属于路由中的一部分，负责静态资源的路径设置 1234567891011121314151617181920212223242526var express = require('express');var app = express();app.use(express.static(__dirname + '/images'));app.use('/pic', express.static(__dirname + '/images'));app.use('/img', express.static(__dirname + '/images'));app.get('/img', function (req, res) &#123; var _html = ''; _html += '&lt;p&gt;/icon.png&lt;/p&gt;&lt;img src=\"/icon.png\" /&gt;'; _html += '&lt;p&gt;/pic/icon.png&lt;/p&gt;&lt;img src=\"/pic/icon.png\" /&gt;'; _html += '&lt;p&gt;/img/icon.png&lt;/p&gt;&lt;img src=\"/img/icon.png\" /&gt;'; res.send(_html);&#125;);var server = app.listen(12345, function () &#123; var host = server.address().address; var port = server.address().port; console.log('Example app listening at http://%s:%s', host, port);&#125;); &nbsp; 六、实例源码github express_demo","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://fredwei.com/tags/nodejs/"},{"name":"express","slug":"express","permalink":"http://fredwei.com/tags/express/"},{"name":"router","slug":"router","permalink":"http://fredwei.com/tags/router/"}]}]